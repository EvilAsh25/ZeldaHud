using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Drawing;
using System.Windows.Forms;

namespace Enemizer
{
    public partial class Randomization
    {
        Random rand;
        byte[] ROM_DATA;

        //194 for firesnake
        //All the sprites address that are dropping keys //check 192,193,
        int[] smallCorridors_sprites = { 0x04DE29 };
        int[] key_sprite = new int[] { 0x04DA20, 0x04DA5C, 0x04DB7F, 0x04DD73, 0x04DDC3, 0x04DE07, 0x04E203, 0x04E20B, 0x04E326, 0x04E4F7, 0x04E70C, 0x04E7C8, 0x04E7FA, 0x04E200, 0x04E687 };
        //All the rooms that need every sprite dead for doors to open
        int[] NeedKillable_doors = { 11, 27, 36, 40, 46, 49, 62, 68, 75, 83, 93, 107, 109, 110, 113, 117, 123, 125, 133, 135, 141, 165, 168, 176, 178, 182, 210, 216, 224, 239, 268, 291 };
        //room 113 is not in needkillable is it in key_sprite?
        //all the sprites "gfx" sheet 
        byte[] sprite_subset_0 = new byte[] { 22, 31, 47, 14 }; //70-72 part of guards we already have 4 guard set don't need more
        byte[] sprite_subset_1 = new byte[] { 44, 30, 32 };//73-13
        byte[] sprite_subset_2 = new byte[] { 12, 18, 23, 24, 28, 46, 34, 35, 39, 40, 38, 41, 36, 42 };//19 trainee guard
        byte[] sprite_subset_3 = new byte[] { 17, 16, 27, 20, 82, 83 };
        //the sprites group avaiable in dungeons there's 60 of them some need to stay the same (npcs, bosses)
        byte[][] random_sprite_group = new byte[60][];
        byte[][] random_sprite_group_ow = new byte[43][];
        //all the sprites that can be used in the subset gfx sheet selected
        byte[][] subset_gfx_sprites = new byte[102][];
        //all the absorbable sprites fairy, bombs, rupees, arrows, ect, that can be used in any rooms without any specific set selected
        byte[] absorbable_sprites = new byte[] { 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4 };

        //All the rooms that require special handling
        byte[] IcemanRoom = { 14, 126, 142, 158, 190 }; //these room need to be locked on the gfx ID : 28
        byte[] WaterRoom = { 40, 56, 54, 70, 52, 22, 102 }; //these room need to be locked on the gfx ID : 17 //118 removed
        byte[] ShadowRoom = { 62, 159 };//28,27,30
        byte[] WallMasterRoom = { 57, 73, 86, 88, 141, 104 };//force 82 on 3
        byte[] bumperandcrystalRoom = {23,4,11,19,27,30,42,43,49,68,76,89,91,103,107,119,135,139,145,146,155,157,161,171,
        182,191,193,196,235, 64, 74, 165, 195,197,213,214,239,61};//also laser shooting eyes //can be 82 or 83 on 3,126
        int[] SwitchesRoom = { 2, 100, 267, 73, 88 };
        byte[] TonguesRoom = { 4, 206, 63, 35, 53, 55, 118 };
        //byte[] PushSwitchesRoom = { 53, 55, 118 }; //83 same as tongue
        int[] noStatueRoom = { 70, 208, 38, 43, 118, 54, 52, 22, 40,87 }; //do not generate statue in these rooms
        
        //ROOM 127 do not spawn  anti-faerie
        byte[] canonRoom = { 92, 117 }; //47 on 0
        int[] canonRoom2 = { 185, 217, 268 };//46 on 2
        


        byte[] NonKillable = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x0B,0x15,0x1C,0x1E,0x21,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x61,0x66,0x67,0x68,0x69,
        0x77,0x7D,0x7E,0x7F,0x82,0x84,0x8A,0x8E,0x90,0x93,0x95,0x96,0x97,0x98,0x9A,0xA1,0xAC,0xC5,0xC6,0xD0,0xD1,0xD8,0xD9,0xDA,0xDB,0xDC,
        0xDD,0xDE,0xDF,0xE0,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0x6F,0x14,0x16,0x1A,0x27,0x28,0x29,0x2A,0x2F,0x32,0x31,0x35,0x36,
        0x38,0x37,0x3C,0x3F,0x40,0x4D,0x57,0x72,0x94,0x95,0x96,0x97,0x98,0x9E,0x9F,0xA0,0xA4,0xA8,0xA9,0xAF,0xAE,0xAD,0xB0,0xB1,0xB2,0xB8,
        0xB7,0xC2,0xCA,0x85,0x81,0x23,0x80,0xA8,0xA9};

        byte[] bowSprites = {0x83,0x84};
        byte[] hammerSprites = { 0x8E };
        StreamWriter spoilerfile;
        bool spoiler = false;
        public Randomization(int seed, int flags, byte[] ROM_DATA, string filename = "newrom.sfc",string skin = "",bool spoiler = false) //Initialization of the randomization
        {
            //We should ask for a original ROM too to prevent any problem while checking the data or including these
            //data in the code [all the original sprites infos 0x3F * 5]
            //We need to patch the ROM first move all headers from their original location to 0x120090
            //Save the ROM as a new file instead of overwriting the original one
            //Save the flags used in a file to remember the last flags that were used
            this.ROM_DATA = ROM_DATA;
            this.spoiler = spoiler;

            if (skin != "Normal Link")
            {
                if (skin != "")
                {
                    FileStream fsx = new FileStream( skin, FileMode.Open, FileAccess.Read);
                    byte[] skin_data = new byte[0x7060];
                    fsx.Read(skin_data, 0, 0x7060);
                    fsx.Close();
                    for (int i = 0; i < 0x7000; i++)
                    {
                        ROM_DATA[0x80000 + i] = skin_data[i];
                    }
                    for (int i = 0; i < 90; i++)
                    {
                        ROM_DATA[0x0DD308 + i] = skin_data[0x7000+i];
                    }
                }

            }


            rand = new Random(seed);
            if (spoiler)
            {
                spoilerfile = new StreamWriter(seed.ToString() + " Spoiler.txt");
         
                spoilerfile.WriteLine("Spoiler Log Seed : " + seed.ToString());

            }
            //Prepare the ROM to be randomized, move header, create new sprites groups

            move_header();
            create_subset_gfx();
            //dungeons
            if (((flags & 0x01) == 0x01))
            {
                
                create_sprite_group();
                patch_sprite_group();
                create_rooms_sprites();
            }

            //overworld
            if ((flags & 0x02) == 0x02)
            {
                create_sprite_overworld_group();
                patch_sprite_group_ow();
                create_overworld_sprites();
            }


            //flags = 1;
            //Do the randomization based on flags!
            bool absorbable = false;
            bool bossmadness = true;
            if ((flags & 0x200) == 0x200) { absorbable = true; } //check if absorbable is on and set it on or off
            if ((flags & 0x400) == 0x400) { bossmadness = false; } //check if absorbable is on and set it on or off
            /*------------------
            |      Flags Informations        
            |0x01|1 - Dungeons Sprites Rand.
            |0x02|2 - Overworld Sprites Rand.
            |0x04|3 - Dungeons Palettes Rand.
            |0x08|4 - Sprite Palettes Rand.
            |0x10|5 - Oveworld Palettes Rand.
            |0x20|6 - Sprites HP Rand.
            |0x40|7 - Sprites DMG Rand.
            |0x80|8 - Sprites HP 0
            |0x100|9 - Bosses Shuffle
            |0x200|10 - Absorbable Sprites
            |0x400|11 - Bosses Madness
             */
             create_dungeons_properties();
            
            if ((flags & 0x01) == 0x01) { Randomize_Dungeons_Sprite(absorbable); }
            
            if ((flags & 0x02) == 0x02) { Randomize_Overworld_Sprite(absorbable); } //WIP
            if ((flags & 0x20) == 0x20) { Randomize_Sprites_HP(); }
            if ((flags & 0x40) == 0x40) { Randomize_Sprites_DMG(); }
            if ((flags & 0x80) == 0x80) { Set_Sprites_ZeroHP(); }
            if ((flags & 0x100) == 0x100 | (flags & 0x400) == 0x400) { Randomize_Bosses(bossmadness); };
            if ((flags & 0x4000) == 0x4000)
            {
                randomizePots();
            }
            //reset seed for all these values so they can be optional
            rand = new Random(seed);
            if ((flags & 0x04) == 0x04) { Randomize_Dungeons_Palettes(); }
            rand = new Random(seed);
            if ((flags & 0x08) == 0x08) { Randomize_Sprites_Palettes(); }
            rand = new Random(seed);
            if ((flags & 0x10) == 0x10) { Randomize_Overworld_Palettes(); } //WIP
            rand = new Random(seed);
            if ((flags & 0x1000) == 0x1000) { shuffle_music(); }
            if ((flags & 0x800) == 0x800)
            {
                black_all_dungeons();
            }
            if (spoiler)
            {
                spoilerfile.Close();
            }

            /*ROM_DATA[0x5033 + 0x5E] = 0x24;
            ROM_DATA[0x5112 + 0x5E] = 0x93;
            ROM_DATA[0x51F1 + 0x5E] = 0x57;

            FileStream fsxx = new FileStream("weapons/mace.bin", FileMode.Open, FileAccess.Read);
            byte[] weapon_data = new byte[fsxx.Length];
            fsxx.Read(weapon_data, 0, (int)fsxx.Length);
            fsxx.Close();
            for (int i = 0; i < (int)weapon_data.Length; i++)
            {
                ROM_DATA[0x0121357 + i] = weapon_data[i];
            }*/

            FileStream fs = new FileStream("Enemizer 5.0 - "+Path.GetFileName(filename), FileMode.OpenOrCreate, FileAccess.Write);
            fs.Write(ROM_DATA, 0, ROM_DATA.Length);
            fs.Close();

            MessageBox.Show("Enemizer 5.0 - " + Path.GetFileName(filename) + " Has been created !");
        }

        


        public bool scan_gtower(byte item) //0x08 = ice rod, 0x07 = fire rod
        {
            if (ROM_DATA[0xEAB8] == item) { return true; };
            if (ROM_DATA[0xEABB] == item) { return true; };
            if (ROM_DATA[0xEABE] == item) { return true; };
            if (ROM_DATA[0xEAC1] == item) { return true; };
            if (ROM_DATA[0xEAD3] == item) { return true; };
            if (ROM_DATA[0xEAD6] == item) { return true; };
            if (ROM_DATA[0xEAD9] == item) { return true; };
            if (ROM_DATA[0xEADC] == item) { return true; };
            if (ROM_DATA[0xEAC4] == item) { return true; };
            if (ROM_DATA[0xEAC7] == item) { return true; };
            if (ROM_DATA[0xEACA] == item) { return true; };
            if (ROM_DATA[0xEACD] == item) { return true; };
            if (ROM_DATA[0xEADF] == item) { return true; };
            if (ROM_DATA[0xEAE2] == item) { return true; };
            if (ROM_DATA[0xEAE5] == item) { return true; };
            if (ROM_DATA[0xEAE8] == item) { return true; };
            if (ROM_DATA[0xEAEB] == item) { return true; };
            if (ROM_DATA[0xEAEE] == item) { return true; };
            if (ROM_DATA[0xEAD0] == item) { return true; };
            if (ROM_DATA[0xEAFD] == item) { return true; };
            if (ROM_DATA[0xEB00] == item) { return true; };
            if (ROM_DATA[0xEB03] == item) { return true; };
            if (ROM_DATA[0xEB06] == item) { return true; };
            if (ROM_DATA[0xEAF4] == item) { return true; };
            if (ROM_DATA[0xEAF7] == item) { return true; };
            if (ROM_DATA[0xEAF1] == item) { return true; };
            if (ROM_DATA[0x180161] == item) { return true; };

            return false;
        }

        //create all the subset gfx set them on null because lots of them need to be unchanged
        public void create_subset_gfx()
        {
            for (int i = 0; i < 102; i++)
            {
                //subset_gfx_sprites[i] = null;
                subset_gfx_sprites[i] = new byte[] { };
            }
            //subset0
            
            subset_gfx_sprites[22] = new byte[] { 0x22, 0x11 };//DW Popo, Hinox, Snapdragon (require 23)
            subset_gfx_sprites[31] = new byte[] { 0x23, 0x24, 0x85, 0xA7, 0x02, 0x7E, 0x7F, 0x80 };//bari,stalfos,firebars
            subset_gfx_sprites[47] = new byte[] { 0x63, 0x64, 0x71 };//delalant,leever
            subset_gfx_sprites[14] = new byte[] { 0x19 };//ghini,thief
            subset_gfx_sprites[70] = new byte[] { 0x6A, 0x6B, 0x49, 0x43, 0x41, 0x42, 0x45, 0x48, 0x44, 0x4A, 0x4B };//need to be combined with 73 and 19 all guards
            subset_gfx_sprites[72] = new byte[] { 0x41, 0x42, 0x43, 0x45, 0x46, 0x47, 0x4B, 0x49 };//need to be combined with 73 and 19 all guards archers
            //subset1
            subset_gfx_sprites[44] = new byte[] { 0x4F, 0x4E, 0x61 }; //popo, beamos
            //13 contains guards same as 73
            subset_gfx_sprites[13] = new byte[] { }; //guards
            subset_gfx_sprites[73] = new byte[] { }; //guards
            subset_gfx_sprites[19] = new byte[] { }; //guards
            subset_gfx_sprites[30] = new byte[] { 0x26, 0x13, 0x18 }; //minihelma,minimoldorm,beetle
            subset_gfx_sprites[32] = new byte[] { 0x9C, 0x9D, 0x91, 0x8F }; //stalfos knight, shadow, blob
            //subset2
            subset_gfx_sprites[12] = new byte[] { 0x08, 0x58, 0x0F }; //octorock,crab,octobaloon
            subset_gfx_sprites[18] = new byte[] { 0x01, 0x4C }; //vulture, jazzhand, (Also contain tablets / rock in front of desert)
            subset_gfx_sprites[23] = new byte[] { 0x12 }; //pigmanspear, snapdragon (require 22) 
            subset_gfx_sprites[24] = new byte[] { 0x08 }; //dwoctorok
            subset_gfx_sprites[28] = new byte[] { 0x6D, 0x6E, 0x6F }; //rat,rope,keese, also the oldman
            subset_gfx_sprites[29] = new byte[] { };
            subset_gfx_sprites[46] = new byte[] { 0x84, 0x83 }; //green/red eyegores
            subset_gfx_sprites[34] = new byte[] { 0x9A, 0x81 }; //water sprites
            subset_gfx_sprites[35] = new byte[] { 0x8B }; //wallmaster,gibdo
            subset_gfx_sprites[39] = new byte[] { 0xC7, 0xCA, 0x5D, 0x5E, 0x5F, 0x60 };//chain chomp,pokey,rollers
            subset_gfx_sprites[40] = new byte[] { 0xA5, 0xA6, 0xC3 };//zazak,gibo (patrick star)
            subset_gfx_sprites[38] = new byte[] { 0x99 };//(A1) iceman,penguin
            subset_gfx_sprites[41] = new byte[] { 0x9B };//wizzrobe
            subset_gfx_sprites[36] = new byte[] { 0x6D, 0x6E, 0x6F };//rat,rope,keese
            subset_gfx_sprites[42] = new byte[] { 0x8E };//turtle,kondongo ,also the digging game guy //0x86 kodongo problem
            //74 = lumberjack
            //subset3
            subset_gfx_sprites[16] = new byte[] { 0x51, 0x27, 0xC9 };//armos,deadrock,tektite
            subset_gfx_sprites[17] = new byte[] { 0x00, 0x0D };//raven,buzzblob
            subset_gfx_sprites[27] = new byte[] { 0xA8, 0xA9, 0xAA };//dw bomber/likelike
            subset_gfx_sprites[20] = new byte[] { 0xD0 };//lynel
            subset_gfx_sprites[74] = new byte[] { 0x9B };//wizzrobe
            subset_gfx_sprites[81] = new byte[] { };//switches
            subset_gfx_sprites[93] = new byte[] { };//sanctuary mantle
            subset_gfx_sprites[82] = new byte[] { 0x8A, 0x1C, 0x15, 0x7D, }; //0x82 };//switches
            subset_gfx_sprites[83] = new byte[] { 0x8A, 0x1C, 0x15, 0x7D, }; //0x82 };//switches
        }

        public byte get_guard_subset_1()
        {
            int i = rand.Next(2);
            if (i == 0) { i = 73; };
            if (i == 1) { i = 13; };
            if (i == 2) { i = 13; };
            return (byte)i;
        }

        public byte[] fully_randomize_that_group()
        {
            return new byte[] { sprite_subset_0[rand.Next(sprite_subset_0.Length)], sprite_subset_1[rand.Next(sprite_subset_1.Length)],
            sprite_subset_2[rand.Next(sprite_subset_2.Length)],sprite_subset_3[rand.Next(sprite_subset_3.Length)]};
        }

        public void create_sprite_overworld_group()
        {
            for (int i = 0; i < 43; i++)
            {
                random_sprite_group_ow[i] = fully_randomize_that_group(); //group from 105 to 124 are empty
            }
            //Creations of the guards group :
            random_sprite_group_ow[0] = new byte[] { 72, get_guard_subset_1(), 19, sprite_subset_3[rand.Next(sprite_subset_3.Length)] }; //Do not randomize that group (Ending thing?)
            random_sprite_group_ow[1] = new byte[] { 70, get_guard_subset_1(), 19, 29 };
            random_sprite_group_ow[2] = new byte[] {72,73,19,29 };
            random_sprite_group_ow[3][3] = 14;
            random_sprite_group_ow[4][2] = 12;
            random_sprite_group_ow[6] = new byte[] {79,73,74,80 };
            random_sprite_group_ow[7][2] = 74;
            random_sprite_group_ow[8][2] = 18; //death montain tablet
            random_sprite_group_ow[9][2] = 18; //desert tablet and rocks
            random_sprite_group_ow[10] = new byte[] {0,73,0,17 };
            random_sprite_group_ow[14] = new byte[] { 93, 44, 12, 68 };
            random_sprite_group_ow[15] = new byte[] {0,0,78,0 };
            random_sprite_group_ow[16][2] = 18;
            random_sprite_group_ow[16][3] = 16;
            random_sprite_group_ow[21] = new byte[] {21,13,23,21 }; 
            random_sprite_group_ow[22] = new byte[] {22,13,24,25 };
            random_sprite_group_ow[27] = new byte[] {75,42,92,21 };

            random_sprite_group_ow[12] = new byte[] { 0, 0, 55, 54};

        }
        //
        public void create_sprite_group()
        {
            //Creations of the guards group :
            random_sprite_group[0] = new byte[] { }; //Do not randomize that group (Ending thing?)
            random_sprite_group[1] = new byte[] { 70, get_guard_subset_1(), 19, sprite_subset_3[rand.Next(sprite_subset_3.Length)] };
            random_sprite_group[2] = new byte[] { 70, get_guard_subset_1(), 19, 83 }; //tongue switch group
            random_sprite_group[3] = new byte[] { 72, get_guard_subset_1(), 19, sprite_subset_3[rand.Next(sprite_subset_3.Length)] };
            random_sprite_group[4] = new byte[] { 72, get_guard_subset_1(), 19, 82 }; //switch group
            random_sprite_group[5] = new byte[] { }; //Do not randomize that group (Npcs, Items, some others thing)
            random_sprite_group[6] = new byte[] { }; //Do not randomize that group (Sanctuary Mantle, Priest)
            random_sprite_group[7] = new byte[] { };//Do not randomize that group (Npcs, Arghus)
            random_sprite_group[8] = fully_randomize_that_group(); //Force Group 8 for Iceman subset2 on 38
            random_sprite_group[8][2] = 38;
            random_sprite_group[9] = new byte[] { };//Do not randomize that group (Armos Knight)
            random_sprite_group[10] = fully_randomize_that_group(); //Force Group 10 for Watersprites subset2 on 34
            random_sprite_group[10][2] = 34;
            random_sprite_group[11] = new byte[] { };//Do not randomize that group (Lanmolas)
            random_sprite_group[12] = new byte[] { }; //Do not randomize that group (Moldorm)
            random_sprite_group[13] = fully_randomize_that_group(); //(Link's House)/Sewer restore uncle (81)
            random_sprite_group[13][0] = 81;
            random_sprite_group[14] = new byte[] { }; //Do not randomize that group (Npcs)
            random_sprite_group[15] = new byte[] { };//Do not randomize that group (Npcs)
            random_sprite_group[16] = new byte[] { }; //Do not randomize that group (Minigame npcs, witch)
            random_sprite_group[17] = fully_randomize_that_group();//Force Group 17 for Shadow(Zoro) Subset 1 on 32
            random_sprite_group[17][1] = 32;
            random_sprite_group[18] = new byte[] { };//Do not randomize that group (Vitreous?,Agahnim)
            random_sprite_group[19] = fully_randomize_that_group();//Force group 19 for Wallmaster Subset2 on 35
            random_sprite_group[19][2] = 35;
            random_sprite_group[20] = new byte[] { }; //Do not randomize that group (Bosses)
            random_sprite_group[21] = new byte[] { }; //Do not randomize that group (Bosses)
            random_sprite_group[22] = new byte[] { };//Do not randomize that group (Bosses)
            random_sprite_group[23] = new byte[] { }; //Do not randomize that group (Bosses)
            random_sprite_group[24] = new byte[] { }; //Do not randomize that group (Bosses)
            random_sprite_group[25] = fully_randomize_that_group();
            random_sprite_group[26] = new byte[] { };//Do not randomize that group (Bosses)
            random_sprite_group[27] = fully_randomize_that_group();//Force group 27 for movingwallcanon subset0 on 47
            random_sprite_group[27][0] = 47;
            random_sprite_group[28] = fully_randomize_that_group();//Force group 27 for canon rooms subset2 on 46
            random_sprite_group[28][2] = 46;
            random_sprite_group[29] = fully_randomize_that_group();
            random_sprite_group[30] = fully_randomize_that_group();
            random_sprite_group[31] = fully_randomize_that_group();
            random_sprite_group[32] = new byte[] { }; //Do not randomize that group (Bosses)
            random_sprite_group[33] = fully_randomize_that_group();
            random_sprite_group[34] = new byte[] { }; //Do not randomize that group (Ganon)
            random_sprite_group[35] = new byte[] { }; //Do not randomize that group (Lanmolas)
            random_sprite_group[36] = fully_randomize_that_group();
            random_sprite_group[37] = fully_randomize_that_group();
            random_sprite_group[38] = fully_randomize_that_group();
            random_sprite_group[39] = fully_randomize_that_group();
            random_sprite_group[40] = new byte[] { }; //Do not randomize that group (Npcs)
            for (int i = 41; i < 60; i++)
            {
                random_sprite_group[i] = fully_randomize_that_group(); //group from 105 to 124 are empty
            }
        }

        public void patch_sprite_group()
        {
            for (int i = 0; i < 60; i++)
            {
                if (random_sprite_group[i].Length != 0)
                {
                    ROM_DATA[0x05C97 + (i * 4)] = random_sprite_group[i][0];
                    ROM_DATA[0x05C97 + (i * 4) + 1] = random_sprite_group[i][1];
                    ROM_DATA[0x05C97 + (i * 4) + 2] = random_sprite_group[i][2];
                    ROM_DATA[0x05C97 + (i * 4) + 3] = random_sprite_group[i][3];
                }
            }
        }

        public void patch_sprite_group_ow()
        {
            for (int i = 0; i < 43; i++)
            {
                if (random_sprite_group_ow[i].Length != 0)
                {
                    
                    ROM_DATA[0x05B97 + (i * 4)] = random_sprite_group_ow[i][0];
                    ROM_DATA[0x05B97 + (i * 4) + 1] = random_sprite_group_ow[i][1];
                    ROM_DATA[0x05B97 + (i * 4) + 2] = random_sprite_group_ow[i][2];
                    ROM_DATA[0x05B97 + (i * 4) + 3] = random_sprite_group_ow[i][3];

                }
            }
        }

        byte[][] dungeons_palettes = new byte[14][];
        public void Randomize_Dungeons_Palettes()
        {
            for (int i = 0; i < 20; i++)
            {
                randomize_wall(i);
                randomize_floors(i);
            }
        }

        public void black_all_dungeons()
        {
            for (int i = 0; i < 3600; i++)
            {
                ROM_DATA[0xDD734 + i] = 0x00;
            }

            //Remove Dark Room
            int[] dark_rooms = new int[] { 11, 25, 33, 34, 50, 65, 66, 106, 146, 147, 153, 181, 186, 192, 208, 228, 229, 230, 231, 240, 241 };
            for(int i = 0;i<dark_rooms.Length;i++)
            {
                ROM_DATA[0x120090 + ((dark_rooms[i] * 14))] = (byte)((ROM_DATA[0x120090 + ((dark_rooms[i] * 14))] & 0xFE));
            }

        }



        public void randomize_wall(int dungeon)
        {

            
            Color wall_color = Color.FromArgb(60+rand.Next(180), 60+rand.Next(180), 60+rand.Next(180));
            byte shade = (byte)(10 + rand.Next(6) -((wall_color.R+wall_color.G+wall_color.B)/80));

            for (int i = 0; i < 5; i++)
            {
                byte shadex = (byte)(shade - (i * 3));
                if (shadex >= 200)
                {
                    shadex = 0;
                }
                setColor((0x0DD734 + (0xB4 * dungeon)) + (i * 2), wall_color, shadex);
                setColor((0x0DD770 + (0xB4 * dungeon)) + (i * 2), wall_color, shadex);
                setColor((0x0DD744 + (0xB4 * dungeon)) + (i * 2), wall_color, shadex);

                /*setColor(0x0DD74C - (i * 2), Color.LimeGreen, (byte)(i * 2));
                setColor(0x0DD778 - (i * 2), Color.LimeGreen, (byte)(i * 2));
                setColor(0x0DD73C - (i * 2), Color.LimeGreen, (byte)(i * 2));*/
            }
            setColor(0x0DD76A + (0xB4 * dungeon), wall_color, (byte)(shade - 6));

            setColor(0x0DD7E4 + (0xB4 * dungeon), wall_color, (byte)(shade-4)); //outer wall darker
            setColor(0x0DD7E6 + (0xB4 * dungeon), wall_color, (byte)(shade - 2)); //outter wall brighter

            setColor((0x0DD7DA + (0xB4 * dungeon)), wall_color, (byte)(shade - (0 * 4)));
            setColor((0x0DD7DA + 2 + (0xB4 * dungeon)), wall_color, (byte)(shade - (1 * 4)));
        }

        public void randomize_floors(int dungeon)
        {


            Color floor_color1 = Color.FromArgb(60 + rand.Next(180), 60 + rand.Next(180), 60 + rand.Next(180));
            Color floor_color2 = Color.FromArgb(60 + rand.Next(180), 60 + rand.Next(180), 60 + rand.Next(180));
            Color floor_color3 = Color.FromArgb(60 + rand.Next(180), 60 + rand.Next(180), 60 + rand.Next(180));
            byte shade1 = (byte)(10 + rand.Next(6) - ((floor_color1.R + floor_color1.G + floor_color1.B) / 80));
            byte shade2 = (byte)(10 + rand.Next(6) - ((floor_color2.R + floor_color2.G + floor_color2.B) / 80));
            byte shade3 = (byte)(10 + rand.Next(6) - ((floor_color3.R + floor_color3.G + floor_color3.B) / 80));

            if (dungeon == 7)
            {
                Console.WriteLine("Dungeon = 7");
                for (int i = 0; i < 3; i++)
                {
                    setColor(0x0DD764 + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade1-1 ) - (i * 3)));
                    setColor(0x0DD782 + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade1) - (i * 3)));
                    setColor(0x0DD7A0 + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade2-1 ) - (i * 3)));
                    setColor(0x0DD7BE + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade2) - (i * 3)));

                    if (i <= 1)
                    {
                        setColor((0x0DD764 + (0xB4 * dungeon) + 8) + (i * 2), floor_color1, (byte)((shade1-1 ) - (i * 3)));
                        setColor((0x0DD782 + (0xB4 * dungeon) + 8) + (i * 2), floor_color1, (byte)((shade1) - (i * 3)));
                        setColor((0x0DD7A0 + (0xB4 * dungeon) + 8) + (i * 2), floor_color1, (byte)((shade2-1 ) - (i * 3)));
                        setColor((0x0DD7BE + (0xB4 * dungeon) + 8) + (i * 2), floor_color1, (byte)((shade2) - (i * 3)));
                    }
                }
                setColor(0x0DD7E2 + (0xB4 * dungeon), floor_color1, 3);
                setColor(0x0DD796 + (0xB4 * dungeon), floor_color1, 3);
            }
            else
            {
                for (int i = 0; i < 3; i++)
                {
                    setColor(0x0DD764 + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade1-1 ) - (i * 3)));
                    setColor(0x0DD782 + (0xB4 * dungeon) + (i * 2), floor_color1, (byte)((shade1 ) - (i * 3)));
                    setColor(0x0DD7A0 + (0xB4 * dungeon) + (i * 2), floor_color2, (byte)((shade2-1 ) - (i * 3)));
                    setColor(0x0DD7BE + (0xB4 * dungeon) + (i * 2), floor_color2, (byte)((shade2) - (i * 3)));

                    if (i <= 1)
                    {
                        setColor((0x0DD764 + (0xB4 * dungeon) + 8) + (i * 2), floor_color3, (byte)((shade3-1 ) - (i * 3)));
                        setColor((0x0DD782 + (0xB4 * dungeon) + 8) + (i * 2), floor_color3, (byte)((shade3) - (i * 3)));
                        setColor((0x0DD7A0 + (0xB4 * dungeon) + 8) + (i * 2), floor_color3, (byte)((shade3-1 ) - (i * 3)));
                        setColor((0x0DD7BE + (0xB4 * dungeon) + 8) + (i * 2), floor_color3, (byte)((shade3 ) - (i * 3)));
                    }
                }

                setColor(0x0DD7E2 + (0xB4 * dungeon), floor_color3, 3);
                setColor(0x0DD796 + (0xB4 * dungeon), floor_color3, 3);
            }
        }

        public void setColor(int address, Color col, byte shade)
        {

            int r = col.R;
            int g = col.G;
            int b = col.B;

            for (int i = 0; i < shade; i++)
            {
                r = (r - (r / 5));
                g = (g - (g/ 5));
                b = (b - (b / 5));
            }
            r = (r / 8);
            g = (g / 8);
            b = (b / 8);
            short s = (short)(((b) << 10) | ((g) << 5) | ((r) << 0));

            ROM_DATA[address] = (byte)(s & 0x00FF);
            ROM_DATA[address + 1] = (byte)((s >> 8) & 0x00FF);


        }



        public void Randomize_Sprites_Palettes()
        {
            //Do not change color of collectible items
            for (int j = 0; j < 0xF3; j++)
            {
                if (j <= 0xD7 || j >= 0xE7)
                {
                    ROM_DATA[0x6B359 + j] = (byte)((ROM_DATA[0x6B359 + j] & 0xF1) + (rand.Next(15) & 0x0E));
                }
            }

        }

        public void Randomize_Overworld_Palettes()
        {
            Color grass = Color.FromArgb(60 + rand.Next(155), 60 + rand.Next(155), 60 + rand.Next(155));

            Color dirt = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            Color wall = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            Color roof = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            Color treetrunk = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            Color treeleaf = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            Color bridge = Color.FromArgb(rand.Next(255), rand.Next(255), rand.Next(255));
            setColor(0x05FEA9, grass, 0);
            for (int i = 0; i < 4; i++)
            {
                
                setColor(0x0DE892 + (i * 70), grass, 1);
                setColor(0x0DE886 + (i * 70), grass, 0);

                setColor(0x0DE6D0 + (i * 70), grass, 1);//grass shade
                setColor(0x0DE6D2 + (i * 70), grass, 0); //grass

                setColor(0x0DE6FA + (i * 70), grass, 3);
                setColor(0x0DE6FC + (i * 70), grass, 0);//grass shade2
                setColor(0x0DE6FE + (i * 70), grass, 0);//??

                setColor(0x0DE70A + (i * 70), grass, 0); //grass?
                setColor(0x0DE708 + (i * 70), grass, 2); //bush?

                setColor(0x0DE70C + (i * 70), grass, 1); //bush?

                Color.FromArgb(60 + rand.Next(155), 60 + rand.Next(155), 60 + rand.Next(155));
                /*setColor(0x0DE6D4 + (i * 70), dirt, 0);

                setColor(0x0DE6CA + (i * 70), dirt, 8);
                setColor(0x0DE6CC + (i * 70), dirt, 4);
                setColor(0x0DE6CE + (i * 70), dirt, 3);
                setColor(0x0DE6E2 + (i * 70), dirt, 0);

                setColor(0x0DE6D8 + (i * 70), dirt, 8);
                setColor(0x0DE6DA + (i * 70), dirt, 4);
                setColor(0x0DE6DC + (i * 70), dirt, 0);
                setColor(0x0DE6F0 + (i * 70), dirt, 0);

                setColor(0x0DE6E6 + (i * 70), dirt, 8);
                setColor(0x0DE6E8 + (i * 70), dirt, 4);
                setColor(0x0DE6EA + (i * 70), dirt, 0);
                setColor(0x0DE6EC + (i * 70), dirt, 4);
                setColor(0x0DE6EE + (i * 70), dirt, 0);
                setColor(0x0DE6F0 + (i * 70), dirt, 0);*/
            }

            /*setColor(0x0DE87C, bridge, 6);
                setColor(0x0DE87E, bridge, 4);
                setColor(0x0DE880, bridge, 2);
                setColor(0x0DE882, bridge, 0);

                setColor(0x0DE86E, wall, 6);
                setColor(0x0DE870, wall, 4);
                setColor(0x0DE872, wall, 2);
                setColor(0x0DE878, wall, 0);

                setColor(0x0DE88A, treetrunk, 4);
                setColor(0x0DE88C, treetrunk, 2);
                setColor(0x0DE88E, treetrunk, 0);
                */

            /*
                setColor(0x0DE890, treeleaf, 4);

                setColor(0x0DE894, treeleaf, 0);

                setColor(0x0DE874, roof, 4);
                setColor(0x0DE876, roof, 0);*/
            
        }

        public void Randomize_Sprites_HP()
        {
            for (int j = 0; j < 0xF3; j++)
            {
                if (ROM_DATA[0x6B173 + j] != 0xFF)
                {
                    if (j != 0x54 && j != 0x09 && j != 0x53 && j != 0x88 && j != 0x89 && j != 0x53 && j != 0x8C && j != 0x92
                        && j != 0x70 && j != 0xBD && j != 0xBE && j != 0xBF && j != 0xCB && j != 0xCE && j != 0xA2 && j != 0xA3
                       && j != 0x8D && j != 0x7A && j != 0x7B && j != 0xCC && j != 0xCD && j != 0xA4 && j != 0xD6 && j != 0xD7)
                    {
                        int new_hp = original_sprites_hp[j];
                        new_hp += (-20 + rand.Next(40));
                        if (new_hp >= 0xFF)
                        {
                            new_hp = 0xFF;
                        }
                        if (new_hp <= 0)
                        {
                            new_hp = 1;
                        }
                        ROM_DATA[0x6B173 + j] = (byte)new_hp;
                    }
                }
            }
        }

        public void shuffle_music()
        {
            for (int i = 0; i < 0x85; i++)
            {
                byte[] musics = new byte[] { 0x03, 0x07, 0x0B, 0x0E, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x22, 0x23 };
                byte m = (byte)rand.Next(musics.Length);
                m = musics[m];
                ROM_DATA[0x015592+i] = m;
            }
        }

        public void Randomize_Sprites_DMG()
        {
            for (int j = 0; j < 0xF3; j++)
            {
                if (j != 0x54 && j != 0x09 && j != 0x53 && j != 0x88 && j != 0x89 && j != 0x53 && j != 0x8C && j != 0x92
&& j != 0x70 && j != 0xBD && j != 0xBE && j != 0xBF && j != 0xCB && j != 0xCE && j != 0xA2 && j != 0xA3 && j != 0x8D
&& j != 0x7A && j != 0x7B && j != 0xCC && j != 0xCD && j != 0xA4 && j != 0xD6 && j != 0xD7)
                {
                    ROM_DATA[0x6B266 + j] = (byte)(rand.Next(8));
                }
            }
        }
    

        public void Set_Sprites_ZeroHP()
        {
            for (int j = 0; j < 0xF3; j++)
            {
                if (ROM_DATA[0x6B173 + j] != 0xFF)
                {
                    if (j != 0x54 && j != 0x09 && j != 0x53 && j != 0x88 && j != 0x89 && j != 0x53 && j != 0x8C && j != 0x92
                        && j != 0x70 && j != 0xBD && j != 0xBE && j != 0xBF && j != 0xCB && j != 0xCE && j != 0xA2 && j != 0xA3
                       && j != 0x8D && j != 0x7A && j != 0x7B && j != 0xCC && j != 0xCD && j != 0xA4 && j != 0xD6 && j != 0xD7)
                    {
                        int new_hp = 1;
                        ROM_DATA[0x6B173 + j] = (byte)new_hp;
                    }
                }
            }
        }


        public enum room_position
        {
            topleft,topright,bottomleft,bottomright,middle
        }



        //Original Rom Data sprites properties
        //NOTE FOR VEETORP ABOUT THESE DATA - I DO NOT ASK FOR A ORIGINAL ROM so i included data directly here you can get
        //these data at the addresses noted at the top of the arrays they are not really useful but if the same rom get
        //patched multiple time it prevent data from being corrupted ;)

        //0x6B173
        byte[] original_sprites_damage = new byte[243]
        {
            0x83, 0x83, 0x81, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x13, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01,
            0x01, 0x08, 0x05, 0x03, 0x40, 0x04, 0x00, 0x02, 0x03, 0x85, 0x00, 0x01, 0x00, 0x40, 0x00, 0x00,
            0x06, 0x00, 0x05, 0x03, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
            0x00, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x01, 0x03, 0x03, 0x03, 0x01, 0x03, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x11, 0x14, 0x01, 0x01, 0x02, 0x05, 0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x08,
            0x08, 0x04, 0x00, 0x04, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00, 0x01, 0x80,
            0x05, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x04, 0x00, 0x00, 0x14, 0x04, 0x06, 0x04, 0x04, 0x04,
            0x04, 0x03, 0x04, 0x04, 0x04, 0x01, 0x04, 0x04, 0x15, 0x05, 0x04, 0x05, 0x15, 0x15, 0x03, 0x05,
            0x00, 0x05, 0x15, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x05, 0x03, 0x06, 0x05, 0x05, 0x03, 0x03,
            0x03, 0x06, 0x17, 0x15, 0x15, 0x05, 0x05, 0x01, 0x85, 0x83, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x17, 0x05,
            0x05, 0x05, 0x04, 0x03, 0x02, 0x10, 0x00, 0x06, 0x00, 0x05, 0x07, 0x17, 0x17, 0x17, 0x15, 0x07,
            0x06, 0x10, 0x00, 0x03, 0x03, 0x00, 0x19, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00};

        //0x6B266
        byte[] original_sprites_hp = new byte[243]
        {
            0x0C, 0x06, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x0C, 0x04, 0xFF, 0x00, 0x03, 0x0C, 0x02,
            0x00, 0x14, 0x04, 0x04, 0x00, 0xFF, 0x00, 0x02, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x03, 0x08, 0x02, 0x02, 0x00, 0x03, 0xFF, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
            0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0xFF,
            0x02, 0x06, 0x04, 0x08, 0x06, 0x08, 0x06, 0x04, 0x08, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x02,
            0xFF, 0x08, 0xFF, 0x30, 0x10, 0x08, 0x08, 0xFF, 0x02, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x03, 0x00, 0x02, 0x04, 0x01,
            0xFF, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x60, 0xFF, 0x18, 0xFF, 0xFF, 0xFF,
            0x03, 0x04, 0xFF, 0x10, 0x08, 0x08, 0x00, 0xFF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x08, 0x08, 0x04,
            0x08, 0x40, 0x30, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x04, 0x02, 0x04, 0x04, 0x08, 0x08,
            0x08, 0x10, 0x40, 0x40, 0x08, 0x04, 0x08, 0x04, 0x04, 0x08, 0x0C, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x30, 0xFF,
            0xFF, 0xFF, 0xFF, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x05, 0x28, 0x28, 0x28, 0x5A, 0x10,
            0x18, 0x40, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00};

        //0x6B359
        byte[] original_palettes_palette = new byte[243]
        {
            0x19, 0x0B, 0x1B, 0x4B, 0x41, 0x41, 0x41, 0x4D, 0x1D, 0x01, 0x1D, 0x19, 0x8D, 0x1B, 0x09, 0x9D,
            0x3D, 0x01, 0x09, 0x11, 0x40, 0x01, 0x4D, 0x19, 0x07, 0x1D, 0x59, 0x80, 0x4D, 0x40, 0x01, 0x49,
            0x1B, 0x41, 0x03, 0x13, 0x15, 0x41, 0x18, 0x1B, 0x41, 0x47, 0x0F, 0x49, 0x4B, 0x4D, 0x41, 0x47,
            0x49, 0x4D, 0x49, 0x40, 0x4D, 0x47, 0x49, 0x41, 0x74, 0x47, 0x5B, 0x58, 0x51, 0x49, 0x1D, 0x5D,
            0x03, 0x19, 0x1B, 0x17, 0x19, 0x17, 0x19, 0x1B, 0x17, 0x17, 0x17, 0x1B, 0x0D, 0x09, 0x19, 0x19,
            0x49, 0x5D, 0x5B, 0x49, 0x0D, 0x03, 0x13, 0x41, 0x1B, 0x5B, 0x5D, 0x43, 0x43, 0x4D, 0x4D, 0x4D,
            0x4D, 0x4D, 0x49, 0x01, 0x00, 0x41, 0x4D, 0x4D, 0x4D, 0x4D, 0x1D, 0x09, 0xC4, 0x0D, 0x0D, 0x09,
            0x03, 0x03, 0x4B, 0x47, 0x47, 0x49, 0x49, 0x41, 0x47, 0x36, 0x8B, 0x49, 0x1D, 0x49, 0x43, 0x43,
            0x43, 0x0B, 0x41, 0x0D, 0x07, 0x0B, 0x1D, 0x43, 0x0D, 0x43, 0x0D, 0x1D, 0x4D, 0x4D, 0x1B, 0x1B,
            0x0A, 0x0B, 0x00, 0x05, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x0B, 0x05, 0x01, 0x01, 0x01, 0x07, 0x17,
            0x19, 0x0D, 0x0D, 0x80, 0x4D, 0x19, 0x17, 0x19, 0x0B, 0x09, 0x0D, 0x4A, 0x12, 0x49, 0xC3, 0xC3,
            0xC3, 0xC3, 0x76, 0x40, 0x59, 0x41, 0x58, 0x4F, 0x73, 0x5B, 0x44, 0x41, 0x51, 0x0A, 0x0B, 0x0B,
            0x4B, 0x00, 0x40, 0x5B, 0x0D, 0x00, 0x00, 0x0D, 0x4B, 0x0B, 0x59, 0x41, 0x0B, 0x0D, 0x01, 0x0D,
            0x0D, 0x00, 0x50, 0x4C, 0x44, 0x51, 0x01, 0x01, 0xF2, 0xF8, 0xF4, 0xF2, 0xD4, 0xD4, 0xD4, 0xF8,
            0xF8, 0xF4, 0xF4, 0xD8, 0xF8, 0xD8, 0xDF, 0xC8, 0x69, 0xC1, 0xD2, 0xD2, 0xDC, 0xC7, 0xC1, 0xC7,
            0xC7, 0xC7, 0xC1};


        public void move_header()
        {
            ROM_DATA[0x0B5E7] = 0x24;//change room header bank to bank to 24

            for (int i = 0; i < 320; i++)
            {
                //get pointer of that room
                byte[] roomPointer = new byte[4];//27502
                roomPointer[0] = ROM_DATA[(0x271E2 + (i * 2) + 0)];
                roomPointer[1] = ROM_DATA[(0x271E2 + (i * 2) + 1)];
                roomPointer[2] = 04;
                int address = BitConverter.ToInt32(roomPointer, 0);
                int pcadd = snestopc(address);

                for (int j = 0; j < 14; j++)
                {
                    ROM_DATA[0x120090 + (i * 14) + j] = ROM_DATA[pcadd + j];
                }
            }


            for (int i = 0; i < 320; i++)
            {
                //0x0271E2  //rewrite all room header address
                //0x120090
                ROM_DATA[0x0271E2 + (i * 2)] = ((byte)pctosnes(0x120090 + (i * 14)));
                ROM_DATA[0x0271E2 + (i * 2) + 1] = ((byte)(pctosnes((0x120090 + (i * 14))) >> 8));

            }
        }

        public int snestopc(int addr)
        {
            int temp = (addr & 0x7FFF) + ((addr / 2) & 0xFF8000);
            return (temp);
        }

        //Convert PC Address to Snes Address
        public int pctosnes(int addr)
        {
            byte[] b = BitConverter.GetBytes(addr);
            b[2] = (byte)(b[2] * 2);
            if (b[1] >= 0x80)
                b[2] += 1;
            else
                b[1] += 0x80;

            return BitConverter.ToInt32(b, 0);
        }


        int[][] overworld_sprites = new int[208][];
        int[] removed_sprites = new int[] { 0x04CF51, };
        int[] water_sprites = new int[] { 0x04D005, 0x04D18E, 0x04D227, 0x04D22A, 0x04D236, 0x04D245, 0x04D24B, 0x04D24E, 0x04D26A, 0x04D281, 0x04D28A, 0x04D2B0, 0x04CBF7, 0x04CC76, 0x04CC79, 0x04CC86, 0x04CDE6, 0x04CDE9, 0x04CDF5, 0x04CDF8, 0x04CDFE, 0x04CE01, 0x04CE50, 0x04CE5C, 0x04CE6E, 0x04CE8D, 0x04CE90, 0x04CE8D, 0x04CE90, 0x04CED0, };
        int[] water_rooms = new int[] { 0x00000F, 0x00002E, 0x000035, 0x000037, 0x00003B, 0x00003F, 0x00004F, 0x000056, 0x000057, 0x000070, 0x000075, 0x000076, 0x000077, 0x00007F, };
  

        int[][] room_sprites = new int[292][];



        public void patch_bosses()
        {
           
            write_rom_data(0x04E5BA,new byte[] { 0x00, 0x05, 0x07, 0xCB, 0x05, 0x07, 0xCC, 0x05, 0x07, 0xCD });

            write_rom_data(0x04E887, new byte[] { 0x00, 0x05, 0x04, 0x53, 0x05, 0x07, 0x53, 0x05, 0x0A, 0x53, 0x08,
                                                  0x0A, 0x53, 0x08, 0x07, 0x53, 0x08, 0x04, 0x53, 0x08, 0xE7, 0x19});

            write_rom_data(0x04EA01, new byte[] { 0x00, 0x05, 0x07, 0xA3, 0x05, 0x07, 0xA4, 0x05, 0x07, 0xA2 });

            write_rom_data(0x04D997, new byte[] { 0x00, 0x07, 0x07, 0x8C, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07,
                                                  0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D,
                                                  0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07,
                                                  0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D, 0x07, 0x07, 0x8D});

            write_rom_data(0x04D9C3, new byte[] { 0x00, 0x09, 0x09, 0x09 });

            write_rom_data(0x04DC31, new byte[] { 0x00, 0x06, 0x08, 0x88, 0xFF });

            write_rom_data(0x04DCCB, new byte[] { 0x00, 0x07, 0x06, 0x54, 0x07, 0x09, 0x54, 0x09, 0x07, 0x54 });

            write_rom_data(0x04E049, new byte[] { 0x00, 0x06, 0x07, 0x92 });

            write_rom_data(0x04E457, new byte[] { 0x00, 0x05, 0x07, 0xBD });

            write_rom_data(0x04E654, new byte[] { 0x00, 0x05, 0x09, 0xCE });


            write_rom_data(0x010979, new byte[] { 0x22, 0x10, 0x92, 0x24 });
            write_rom_data(0x010C16, new byte[] { 0x22, 0x10, 0x92, 0x24 });
            write_rom_data(0x011338, new byte[] { 0x22, 0x10, 0x92, 0x24 });
            write_rom_data(0x010256, new byte[] { 0x22, 0x10, 0x92, 0x24 });

            write_rom_data(0x0FA15C, new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0x61, 0x18, 0xFF, 0xFF });
            write_rom_data(0x06B6BE, new byte[] { 0x00 });

            write_rom_data(0x121210, new byte[] { 0x22, 0x14, 0xC1, 0x09, 0xA5, 0xA0, 0xA6, 0xA1, 0xC9, 0x07, 0xD0, 0x07, 0xE0, 0x00, 0xD0, 0x03,
                                                0x82, 0x5F, 0x00, 0xC9, 0xC8, 0xD0, 0x03, 0x82, 0xC2, 0x00, 0xC9, 0x29, 0xD0, 0x03, 0x82, 0xBB,
                                                0x00, 0xC9, 0x33, 0xD0, 0x03, 0x82, 0xE9, 0x00, 0xC9, 0x5A, 0xD0, 0x03, 0x82, 0xAD, 0x00, 0xC9,
                                                0x90, 0xD0, 0x03, 0x82, 0xDB, 0x00, 0xC9, 0xAC, 0xD0, 0x03, 0x82, 0x9F, 0x00, 0xC9, 0x06, 0xD0,
                                                0x07, 0xE0, 0x00, 0xD0, 0x03, 0x82, 0xC9, 0x00, 0xC9, 0xDE, 0xD0, 0x03, 0x82, 0x58, 0x00, 0xC9,
                                                0xA4, 0xD0, 0x03, 0x82, 0xBB, 0x00, 0xC9, 0x1C, 0xD0, 0x07, 0xE0, 0x00, 0xD0, 0x03, 0x82, 0x7B,
                                                0x00, 0xC9, 0x6C, 0xD0, 0x03, 0x82, 0xA9, 0x00, 0xC9, 0x4D, 0xD0, 0x03, 0x82, 0x03, 0x00, 0x82,
                                                0xD4, 0x00, 0xA2, 0x00, 0xBD, 0x10, 0x0D, 0x18, 0x69, 0x68, 0x9D, 0x10, 0x0D, 0xBD, 0x00, 0x0D,
                                                0x18, 0x69, 0x68, 0x9D, 0x00, 0x0D, 0xE8, 0xE0, 0x10, 0xD0, 0xE9, 0xA2, 0x00, 0xBD, 0x08, 0x0B,
                                                0x18, 0x69, 0x68, 0x9D, 0x08, 0x0B, 0xBD, 0x18, 0x0B, 0x18, 0x69, 0x68, 0x9D, 0x18, 0x0B, 0xE8,
                                                0xE0, 0x08, 0xD0, 0xE9, 0x82, 0x9F, 0x00, 0xA2, 0x00, 0xBD, 0x20, 0x0D, 0x18, 0x69, 0x00, 0x9D,
                                                0x20, 0x0D, 0xBD, 0x30, 0x0D, 0x18, 0x69, 0x01, 0x9D, 0x30, 0x0D, 0xE8, 0xE0, 0x10, 0xD0, 0xE9,
                                                0xA2, 0x00, 0xBD, 0x10, 0x0B, 0x18, 0x69, 0x01, 0x9D, 0x10, 0x0B, 0xBD, 0x20, 0x0B, 0x18, 0x69,
                                                0x00, 0x9D, 0x20, 0x0B, 0xE8, 0xE0, 0x08, 0xD0, 0xE9, 0x82, 0x6A, 0x00, 0xA2, 0x00, 0xBD, 0x20,
                                                0x0D, 0x18, 0x69, 0x01, 0x9D, 0x20, 0x0D, 0xBD, 0x30, 0x0D, 0x18, 0x69, 0x01, 0x9D, 0x30, 0x0D,
                                                0xE8, 0xE0, 0x10, 0xD0, 0xE9, 0xA2, 0x00, 0xBD, 0x10, 0x0B, 0x18, 0x69, 0x01, 0x9D, 0x10, 0x0B,
                                                0xBD, 0x20, 0x0B, 0x18, 0x69, 0x01, 0x9D, 0x20, 0x0B, 0xE8, 0xE0, 0x08, 0xD0, 0xE9, 0x82, 0x35,
                                                0x00, 0xA2, 0x00, 0xBD, 0x20, 0x0D, 0x18, 0x69, 0x01, 0x9D, 0x20, 0x0D, 0xBD, 0x30, 0x0D, 0x18,
                                                0x69, 0x00, 0x9D, 0x30, 0x0D, 0xE8, 0xE0, 0x10, 0xD0, 0xE9, 0xA2, 0x00, 0xBD, 0x10, 0x0B, 0x18,
                                                0x69, 0x00, 0x9D, 0x10, 0x0B, 0xBD, 0x20, 0x0B, 0x18, 0x69, 0x01, 0x9D, 0x20, 0x0B, 0xE8, 0xE0,
                                                0x08, 0xD0, 0xE9, 0x82, 0x00, 0x00, 0x6B});

        }


        public void write_rom_data(int pos, byte[] data)
        {
            for(int i =0;i<data.Length;i++)
            {
                ROM_DATA[pos + i] = data[i];
            }
        }






    byte[] slime_boss = new byte[]
    { 0xE4, 0x21, 0x00, 0x05, 0x03, 0x00, 0x07, 0x03, 0x0C, 0x07, 0x24, 0x00, 0x02, 0x03, 0x04, 0x08,
    0x23, 0x00, 0x06, 0x0F, 0x00, 0x3E, 0x0F, 0xF0, 0x3F, 0xC0, 0x45, 0xFF, 0x00, 0x03, 0x00, 0x0F,
    0x30, 0xC0, 0x24, 0x00, 0x03, 0x7F, 0x00, 0xFF, 0x7F, 0x4A, 0x00, 0xFF, 0x01, 0x7F, 0x80, 0xE4,
    0x26, 0x00, 0x05, 0x01, 0x00, 0x03, 0x01, 0x02, 0x01, 0x24, 0x00, 0x0D, 0x01, 0x02, 0x02, 0x01,
    0x00, 0x0F, 0x01, 0x1E, 0x0F, 0x70, 0x1F, 0xE0, 0x7F, 0x80, 0x44, 0xFF, 0x00, 0x03, 0x01, 0x0E,
    0x10, 0x60, 0x83, 0x5A, 0x00, 0x02, 0xFF, 0x00, 0xFF, 0x4C, 0xFF, 0x00, 0x00, 0xFF, 0x27, 0x00,
    0x07, 0xFF, 0xC0, 0x3F, 0xF8, 0x07, 0x9E, 0x01, 0x9F, 0x43, 0x00, 0xFF, 0x0A, 0x81, 0x7E, 0xE3,
    0x00, 0xC0, 0xF8, 0xFE, 0xFF, 0xFF, 0x7E, 0x1C, 0x50, 0x00, 0xFF, 0xE4, 0xAE, 0x00, 0x09, 0x18,
    0x0F, 0x38, 0x1F, 0x30, 0x1F, 0x70, 0x3F, 0x60, 0x3F, 0x45, 0xE0, 0x7F, 0x04, 0x10, 0x20, 0x20,
    0x40, 0x40, 0x22, 0x80, 0x98, 0xD8, 0x00, 0xF0, 0x2E, 0xD9, 0x00, 0x45, 0x06, 0x03, 0x45, 0x0C,
    0x07, 0x43, 0x1C, 0x0F, 0x22, 0x04, 0x22, 0x08, 0x01, 0x10, 0x10, 0xF0, 0x2F, 0xB0, 0x01, 0x0C,
    0x1C, 0xFF, 0xE0, 0xFF, 0xFC, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x1F, 0x03, 0x03, 0x25, 0x00, 0x06,
    0x80, 0x60, 0x1C, 0x03, 0x00, 0x00, 0xFF, 0x83, 0x37, 0x00, 0x02, 0xF8, 0xC7, 0xF0, 0x23, 0xFF,
    0x0A, 0x3F, 0x3F, 0x00, 0x00, 0x0F, 0x3F, 0x38, 0x00, 0x00, 0xC0, 0x3F, 0xE4, 0xA7, 0x00, 0x43,
    0xE0, 0x7F, 0x43, 0xF0, 0x7F, 0x43, 0x78, 0x3F, 0x03, 0x3E, 0x1F, 0x1F, 0x0F, 0x23, 0x80, 0x07,
    0x40, 0x40, 0x20, 0x10, 0x00, 0xFF, 0x3C, 0xC3, 0x48, 0xFF, 0x00, 0x09, 0xC3, 0x3C, 0xFF, 0x00,
    0x3C, 0xCF, 0xCF, 0xFF, 0xFF, 0x3C, 0xF0, 0x30, 0xC7, 0x01, 0x47, 0x1C, 0x0F, 0x43, 0x0E, 0x07,
    0x03, 0x06, 0x03, 0x07, 0x03, 0x23, 0x10, 0x1A, 0x08, 0x08, 0x04, 0x04, 0x00, 0xFF, 0x20, 0xDF,
    0x38, 0xC7, 0x3C, 0xF3, 0x0E, 0xF9, 0x1E, 0xE1, 0x7E, 0x87, 0x78, 0xFF, 0x00, 0x20, 0x38, 0x0C,
    0x06, 0x1E, 0x78, 0x99, 0xC7, 0x01, 0x84, 0x91, 0x03, 0x06, 0x3D, 0xF2, 0x0F, 0xF8, 0x1F, 0xE0,
    0x7F, 0x85, 0x9D, 0x03, 0x02, 0x0D, 0x07, 0x1F, 0x83, 0xA6, 0x03, 0x02, 0x20, 0xDF, 0xE0, 0x84,
    0x97, 0x00, 0x0C, 0xC0, 0x3F, 0xF0, 0x0F, 0xF0, 0xFF, 0x00, 0x20, 0xE0, 0x80, 0x00, 0xC0, 0xF0,
    0xE4, 0xA8, 0x00, 0x03, 0x0F, 0x07, 0x07, 0x01, 0x85, 0x87, 0x00, 0x25, 0x00, 0x01, 0x08, 0x06,
    0x86, 0x9C, 0x04, 0x98, 0x41, 0x02, 0x43, 0x7F, 0x80, 0x02, 0xFF, 0xC0, 0xFF, 0x83, 0x60, 0x02,
    0x83, 0x65, 0x02, 0x03, 0x7F, 0x40, 0x30, 0x0F, 0x9A, 0x6D, 0x02, 0x43, 0x03, 0x01, 0x8B, 0x9C,
    0x04, 0x83, 0x8E, 0x00, 0xF0, 0x34, 0xAC, 0x04, 0x98, 0x41, 0x02, 0x43, 0x00, 0xFF, 0x01, 0xC7,
    0xF8, 0x88, 0xD0, 0x04, 0x02, 0x00, 0x00, 0x07, 0x9B, 0xDC, 0x04, 0xE4, 0x77, 0x00, 0xFF, 0x8A,
    0x18, 0x69, 0x10, 0xAA, 0x22, 0xCC, 0x93, 0x24, 0xAE, 0xA0, 0x0F, 0x6B, 0xBD, 0x40, 0x0D, 0xF0,
    0x28, 0x0A, 0x0A, 0x0A, 0x0A, 0x18, 0x7D, 0x60, 0x0D, 0x9D, 0x60, 0x0D, 0xBD, 0x40, 0x0D, 0x08,
    0x4A, 0x4A, 0x4A, 0x4A, 0xA0, 0x00, 0x28, 0x10, 0x03, 0x09, 0xF0, 0x88, 0x7D, 0x00, 0x0D, 0x9D,
    0x00, 0x0D, 0x98, 0x7D, 0x20, 0x0D, 0x9D, 0x20, 0x0D, 0x6B, 0xBD, 0x80, 0x0F, 0x0A, 0x0A, 0x0A,
    0x0A, 0x18, 0x7D, 0x90, 0x0F, 0x9D, 0x90, 0x0F, 0xBD, 0x80, 0x0F, 0x08, 0x4A, 0x4A, 0x4A, 0x4A,
    0x28, 0x10, 0x02, 0x09, 0xF0, 0x7D, 0x70, 0x0F, 0x9D, 0x70, 0x0F, 0x6B, 0x22, 0xCC, 0x93, 0x24,
    0x22, 0xBF, 0x93, 0x24, 0x6B, 0x22, 0xFA, 0x93, 0x24, 0x22, 0xBF, 0x93, 0x24, 0x22, 0xCC, 0x93,
    0x24, 0x6B, 0x22, 0xFA, 0x93, 0x24, 0xDE, 0x80, 0x0F, 0xDE, 0x80, 0x0F, 0xBD, 0x70, 0x0F, 0x10,
    0x14, 0x9E, 0x70, 0x0F, 0xA5, 0x08, 0x9D, 0x80, 0x0F, 0xA5, 0x09, 0x22, 0x18, 0xEA, 0x06, 0xA9,
    0x21, 0x22, 0x7C, 0xBB, 0x0D, 0xBD, 0x70, 0x0F, 0xF0, 0x04, 0x22, 0x1C, 0x94, 0x24, 0x6B, 0xBD,
    0xD0, 0x0D, 0xC9, 0x09, 0xD0, 0x13, 0xAD, 0xC1, 0x0F, 0xD0, 0x0E, 0xA5, 0x11, 0xD0, 0x0A, 0xBD,
    0xAA, 0x0C, 0x30, 0x08, 0xBD, 0x00, 0x0F, 0xF0, 0x03, 0x68, 0x68, 0x68, 0x6B, 0xBD, 0xA0, 0x0D,
    0xD0, 0x07, 0x1A, 0x9D, 0xA0, 0x0D, 0x20, 0xCD, 0x94, 0x20, 0xE3, 0x95, 0xBD, 0x50, 0x0E, 0x38,
    0xE9, 0x01, 0x10, 0x03, 0x20, 0x9F, 0x95, 0x22, 0x5F, 0x94, 0x24, 0xBD, 0xA0, 0x0D, 0xC9, 0x01,
    0xD0, 0x07, 0x1A, 0x9D, 0xA0, 0x0D, 0x20, 0xEF, 0x94, 0x20, 0xF0, 0x94, 0xBD, 0x00, 0x0E, 0xD0,
    0x03, 0x20, 0x8A, 0x95, 0xBD, 0x10, 0x0E, 0xD0, 0x03, 0x20, 0x90, 0x95, 0xBD, 0xE0, 0x0E, 0xD0,
    0x03, 0x20, 0x9E, 0x95, 0xBD, 0xE2, 0x0C, 0xF0, 0x03, 0x20, 0x74, 0x95, 0x6B, 0x9E, 0x90, 0x0D,
    0xBD, 0x50, 0x0F, 0x29, 0xF1, 0x09, 0x04, 0x9D, 0x50, 0x0F, 0xA9, 0x00, 0x9D, 0xB0, 0x0D, 0xA9,
    0x40, 0x9D, 0x00, 0x0E, 0xBD, 0x60, 0x0F, 0x29, 0xE0, 0x09, 0x07, 0x9D, 0x60, 0x0F, 0x60, 0x60,
    0xA9, 0x10, 0x85, 0x09, 0xA9, 0x20, 0x85, 0x08, 0xBD, 0xB0, 0x0D, 0x3A, 0xF0, 0x08, 0xA9, 0x10,
    0x85, 0x09, 0xA9, 0x10, 0x85, 0x08, 0x20, 0x12, 0x95, 0x22, 0xB0, 0xF2, 0x06, 0x22, 0x2F, 0xF1,
    0x06, 0x60, 0xBD, 0x90, 0x0D, 0xF0, 0x5C, 0x22, 0xFA, 0x93, 0x24, 0xDE, 0x80, 0x0F, 0xDE, 0x80,
    0x0F, 0xBD, 0x70, 0x0F, 0x10, 0x26, 0x9E, 0x70, 0x0F, 0xBD, 0xB0, 0x0D, 0xD0, 0x0A, 0xA9, 0x10,
    0x9D, 0x00, 0x0E, 0x9E, 0x90, 0x0D, 0x80, 0x00, 0xA5, 0x08, 0x9D, 0x80, 0x0F, 0xA5, 0x09, 0x22,
    0x18, 0xEA, 0x06, 0xA9, 0x21, 0x22, 0x7C, 0xBB, 0x0D, 0x9E, 0xC0, 0x0D, 0xBD, 0x70, 0x0F, 0xF0,
    0x22, 0xA9, 0x01, 0x9D, 0xC0, 0x0D, 0x22, 0x1C, 0x94, 0x24, 0x22, 0x9C, 0xE4, 0x06, 0xBD, 0x70,
    0x0E, 0xF0, 0x10, 0xBD, 0x40, 0x0D, 0x49, 0xFF, 0x9D, 0x40, 0x0D, 0xBD, 0x50, 0x0D, 0x49, 0xFF,
    0x9D, 0x50, 0x0D, 0x60, 0xBD, 0x50, 0x0F, 0x29, 0xF1, 0x09, 0x0A, 0x9D, 0x50, 0x0F, 0xA9, 0x40,
    0x9D, 0x10, 0x0E, 0xA9, 0x02, 0x9D, 0xB0, 0x0D, 0x60, 0x60, 0xA9, 0x01, 0x9D, 0x90, 0x0D, 0x60,
    0x9E, 0xB0, 0x0D, 0xBD, 0x50, 0x0F, 0x29, 0xF1, 0x09, 0x04, 0x9D, 0x50, 0x0F, 0x60, 0x60, 0xA9,
    0x40, 0x9D, 0x10, 0x0E, 0xA9, 0x01, 0x9D, 0xB0, 0x0D, 0xBD, 0xA0, 0x0D, 0xC9, 0x03, 0xF0, 0x32,
    0x9C, 0xD0, 0x0D, 0x9C, 0xD1, 0x0D, 0x9C, 0xD3, 0x0D, 0x9C, 0xD4, 0x0D, 0x9C, 0xD5, 0x0D, 0x9C,
    0xD6, 0x0D, 0x9C, 0xD7, 0x0D, 0x9C, 0xD8, 0x0D, 0x9C, 0xD9, 0x0D, 0x9C, 0xDA, 0x0D, 0x9C, 0xDB,
    0x0D, 0x9C, 0xDC, 0x0D, 0x9C, 0xDD, 0x0D, 0x9C, 0xDE, 0x0D, 0x9C, 0xDF, 0x0D, 0xA9, 0x03, 0x9D,
    0xA0, 0x0D, 0x60, 0x22, 0x1C, 0xE4, 0x06, 0xBD, 0xC0, 0x0D, 0x0A, 0x0A, 0x0A, 0x85, 0x06, 0xBD,
    0xB0, 0x0D, 0x85, 0x09, 0xDA, 0xA2, 0x07, 0xDA, 0x8A, 0x18, 0x65, 0x06, 0x48, 0x0A, 0xAA, 0xC2,
    0x20, 0xA5, 0x00, 0x18, 0x7F, 0x76, 0x96, 0x24, 0x91, 0x90, 0x29, 0x00, 0x01, 0x85, 0x0E, 0xA5,
    0x02, 0x18, 0x7F, 0x96, 0x96, 0x24, 0xC8, 0x91, 0x90, 0x18, 0x69, 0x10, 0x00, 0xC9, 0x00, 0x01,
    0xE2, 0x20, 0x90, 0x04, 0xA9, 0xF0, 0x91, 0x90, 0xFA, 0xA5, 0x09, 0xF0, 0x24, 0x80, 0x12, 0xC9,
    0x01, 0xD0, 0x07, 0xA9, 0xE8, 0xC8, 0x91, 0x90, 0x80, 0x1E, 0xA9, 0xC8, 0xC8, 0x91, 0x90, 0x80,
    0x17, 0xE0, 0x03, 0xF0, 0xEA, 0xE0, 0x04, 0xF0, 0xE6, 0xE0, 0x0B, 0xF0, 0xE2, 0xE0, 0x0C, 0xF0,
    0xDE, 0xBF, 0xB6, 0x96, 0x24, 0xC8, 0x91, 0x90, 0xBF, 0xC6, 0x96, 0x24, 0x05, 0x05, 0xC8, 0x91,
    0x90, 0x5A, 0x98, 0x4A, 0x4A, 0xA8, 0xBF, 0xD6, 0x96, 0x24, 0x05, 0x0F, 0x91, 0x92, 0x7A, 0xC8,
    0xFA, 0xCA, 0x10, 0x83, 0xFA, 0x60, 0xEA, 0xFF, 0xFA, 0xFF, 0xEA, 0xFF, 0xFA, 0xFF, 0x0A, 0x00,
    0x0A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0xEA, 0xFF, 0xFA, 0xFF, 0xEA, 0xFF, 0xFA, 0xFF, 0x0A, 0x00,
    0x0A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0xF4, 0xFF, 0xF4, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00,
    0xF4, 0xFF, 0xF4, 0xFF, 0x04, 0x00, 0xF4, 0xFF, 0xF4, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00,
    0xF4, 0xFF, 0xF4, 0xFF, 0x04, 0x00, 0xC0, 0xC2, 0xE0, 0xE2, 0xE2, 0xC2, 0xC0, 0xE0, 0xC4, 0xC6,
    0xE4, 0xE6, 0xE6, 0xC6, 0xC4, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02
};












    }








}
